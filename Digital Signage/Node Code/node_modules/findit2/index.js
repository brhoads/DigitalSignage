var fs = require('fs');
var path = require('path');
var EventEmitter = require('events').EventEmitter;
var Seq = require('seq');

function createInodeChecker() {
    var inodes = {};
    return function inodeSeen(inode) {
        if (inodes[inode]) {
            return true;
        } else {
            inodes[inode] = true;
            return false;
        }
    }
}

exports = module.exports = find;
exports.find = find;
function find (base, options, cb) {
    cb = arguments[arguments.length - 1];
    if (typeof(cb) !== 'function') {
        cb = undefined;
    }
    var em = new EventEmitter;
    var inodeSeen = createInodeChecker();
    options = options || {};

    function finder (dir, f) {
        Seq()
            .seq(fs.readdir, dir, Seq)
            .flatten()
            .seqEach(function (file) {
                var p = dir + '/' + file;
                fs.lstat(p, this.into(p));
            })
            .seq(function () {
                var files = Object.keys(this.vars);

                if (options.ignore) {
                    files = files.filter(function (file) {
                        return !ignore(path.relative(base, file), options.ignore);
                    });
                }

                this(null, files);
            })
            .flatten()
            .seqEach(function (file) {
                var stat = this.vars[file],
                    rel = path.relative(base, file),
                    name = options.relative ? rel : file;

                if (cb) cb(name, stat);

                // Windows doesn't support iNode and just sets it to 0
                if (stat.ino && inodeSeen(stat.ino)) {
                    // already seen this inode, probably a recursive symlink
                    this(null);
                }
                else {
                    em.emit('path', file, stat);

                    if (stat.isSymbolicLink()) {
                        em.emit('link', file, stat);
                        if (options.follow_symlinks) {
                          fs.exists(file, function(exists) {
                            if (exists) {
                              fs.readlink(file, function(err, resolvedPath) {
                                if (err) {
                                  em.emit('error', err);
                                } else {
                                  finder(path.resolve(path.dir(file), resolvedPath));
                                }
                              });
                            }
                          });
                        } else {
                          this(null);
                        }
                    }
                    else if (stat.isDirectory()) {
                        em.emit('directory', name, stat);
                        finder(file, this);
                    }
                    else {
                        em.emit('file', name, stat);
                        this(null);
                    }
                }
            })
            .seq(f.bind({}, null))
            .catch(em.emit.bind(em, 'error'))
        ;
    }

    fs.lstat(base, function (err, s) {
        if (err) {
            em.emit('error', err);
            return;
        }
        if (s.isDirectory()) {
            finder(base, em.emit.bind(em, 'end'));
        }
        else if (s.isSymbolicLink()) {
            if (cb) cb(base, s);
            em.emit('link', base, s);
            em.emit('end');
        }
        else {
            if (cb) cb(base, s);
            em.emit('file', base, s);
            em.emit('end');
        }
    });

    return em;
};

exports.findSync = function findSync(dir, options, cb) {
    cb = arguments[arguments.length - 1];
    if (typeof(cb) !== 'function') {
        cb = undefined;
    }
    options = options || {};
    var inodeSeen = createInodeChecker();
    var files = [];
    var fileQueue = [];
    var rule = options.ignore;
    var processFile = function processFile(file) {
        var stat = fs.lstatSync(file),
            rel = path.relative(dir, file),
            name = options.relative ? rel : file;
        if (inodeSeen(stat.ino)) {
            return;
        }
        files.push(name);
        cb && cb(name, stat);
        if (stat.isDirectory()) {
            fs.readdirSync(file).forEach(function(f) {
                var full = path.join(file, f);

                if (rule && ignore(path.relative(dir, full), rule)) {
                    return;
                }

                fileQueue.push(full);
            });
        } else if (stat.isSymbolicLink()) {
            if (options && options.follow_symlinks && fs.existsSync(file)) {
                fileQueue.push(fs.realpathSync(file));
            }
        }
    };
    /* we don't include the starting directory unless it is a file */
    var stat = fs.lstatSync(dir);
    if (stat.isDirectory()) {
        fs.readdirSync(dir).forEach(function(f) {
            var full = path.join(dir, f);

            if (rule && ignore(path.relative(dir, full), rule)) {
                return;
            }

            fileQueue.push(full);
        });
    } else {
        fileQueue.push(dir);
    }
    while (fileQueue.length > 0) {
        processFile(fileQueue.shift());
    }
    return files;
};

exports.find.sync = exports.findSync;

function ignore(file, rule) {
    if (Array.isArray(rule)) {
        return rule.some(function (rule) {
            return ignore(file, rule);
        });
    }

    if (typeof rule === "string" && file.slice(0, rule.length) === rule) {
        return true;
    } else if (rule instanceof RegExp && rule.test(file)) {
        return true;
    }

    return false;
}
